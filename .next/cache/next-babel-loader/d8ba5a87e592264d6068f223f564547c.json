{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst url = 'ws://localhost:8080';\n/**\r\n * QueueWebSocket controls the web socket business logic for the course queue and\r\n * functions as a controller for the queue state\r\n */\n\nexport default class QueueWebSocketController {\n  constructor(component) {\n    this.component = component;\n  }\n\n  start() {\n    this.connection = new WebSocket(url);\n    this.connection.onopen = this.processConnectionOpen.bind(this);\n    this.connection.onerror = this.processConnectionError.bind(this);\n    this.connection.onmessage = this.processConnectionMessage.bind(this);\n  }\n\n  processConnectionOpen() {\n    const {\n      courseId\n    } = this.component;\n    this.connection.send(this.prepareMessage({\n      msgType: 'greeting',\n      msg: courseId\n    })); // notify the server which courseId this websocket belongs to\n  }\n\n  processConnectionError(error) {\n    console.log(`WebSocket error: ${error}`);\n  }\n\n  activateYourTurnModal() {\n    this.component.setState({\n      isYourTurn: true\n    });\n  }\n\n  activateTAWaitingModal(studentName) {\n    this.component.setState({\n      inviteNextStudent: true,\n      nextStudentName: studentName\n    });\n  }\n\n  updateStudentsInQueue(msg) {\n    this.component.setState({\n      studentsInQueue: msg\n    });\n  }\n\n  processConnectionMessage(e) {\n    const {\n      msgType,\n      msg\n    } = JSON.parse(e.data);\n\n    switch (msgType) {\n      case 'queue':\n        // in this case, the server will send a message indicating the current students in the queue\n        // msg - the new queue\n        this.updateStudentsInQueue(msg);\n        break;\n\n      case 'yourTurn':\n        // in this case, which os only if you arw a student, the server notifies that it is your turn\n        this.activateYourTurnModal();\n        break;\n\n      case 'nextStudentNotified':\n        // in this case, the server lets the TA know that the student has been notified\n        // msg - the name of the student who was notified\n        this.activateTAWaitingModal(msg);\n        break;\n\n      default:\n        throw new Error(`Message ${msg} is incorrectly formatted`);\n    }\n  }\n\n  addMeToQueue() {\n    const {\n      me\n    } = this.component.state;\n    this.connection.send(this.prepareMessage({\n      msgType: 'addToQueue',\n      msg: JSON.stringify(me)\n    }));\n  }\n\n  removeMeFromQueue() {\n    const {\n      me\n    } = this.component.state;\n    this.connection.send(this.prepareMessage({\n      msgType: 'removeFromQueue',\n      msg: JSON.stringify(me)\n    }));\n  }\n\n  getNextStudent() {\n    this.connection.send(this.prepareMessage({\n      msgType: 'next',\n      msg: 'next'\n    }));\n  }\n\n  prepareMessage(msg) {\n    const {\n      courseId\n    } = this.component;\n\n    const enrichedPayload = _objectSpread(_objectSpread({}, msg), {}, {\n      courseId\n    });\n\n    return JSON.stringify(enrichedPayload);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/ryanj/Documents/mercury/components/queue/queuews.js"],"names":["url","QueueWebSocketController","constructor","component","start","connection","WebSocket","onopen","processConnectionOpen","bind","onerror","processConnectionError","onmessage","processConnectionMessage","courseId","send","prepareMessage","msgType","msg","error","console","log","activateYourTurnModal","setState","isYourTurn","activateTAWaitingModal","studentName","inviteNextStudent","nextStudentName","updateStudentsInQueue","studentsInQueue","e","JSON","parse","data","Error","addMeToQueue","me","state","stringify","removeMeFromQueue","getNextStudent","enrichedPayload"],"mappings":"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","sourcesContent":["const url = 'ws://localhost:8080'\r\n\r\n/**\r\n * QueueWebSocket controls the web socket business logic for the course queue and\r\n * functions as a controller for the queue state\r\n */\r\n\r\nexport default class QueueWebSocketController {\r\n  constructor(component) {\r\n    this.component = component\r\n  }\r\n\r\n  start() {\r\n    this.connection = new WebSocket(url)\r\n    this.connection.onopen = this.processConnectionOpen.bind(this)\r\n    this.connection.onerror = this.processConnectionError.bind(this)\r\n    this.connection.onmessage = this.processConnectionMessage.bind(this)\r\n  }\r\n\r\n  processConnectionOpen() {\r\n    const { courseId } = this.component\r\n\r\n    this.connection.send(\r\n      this.prepareMessage({\r\n        msgType: 'greeting',\r\n        msg: courseId,\r\n      })\r\n    ) // notify the server which courseId this websocket belongs to\r\n  }\r\n\r\n  processConnectionError(error) {\r\n    console.log(`WebSocket error: ${error}`)\r\n  }\r\n\r\n  activateYourTurnModal() {\r\n    this.component.setState({ isYourTurn: true })\r\n  }\r\n\r\n  activateTAWaitingModal(studentName) {\r\n    this.component.setState({\r\n      inviteNextStudent: true,\r\n      nextStudentName: studentName,\r\n    })\r\n  }\r\n\r\n  updateStudentsInQueue(msg) {\r\n    this.component.setState({ studentsInQueue: msg })\r\n  }\r\n\r\n  processConnectionMessage(e) {\r\n    const { msgType, msg } = JSON.parse(e.data)\r\n\r\n    switch (msgType) {\r\n      case 'queue': // in this case, the server will send a message indicating the current students in the queue\r\n        // msg - the new queue\r\n        this.updateStudentsInQueue(msg)\r\n        break\r\n\r\n      case 'yourTurn': // in this case, which os only if you arw a student, the server notifies that it is your turn\r\n        this.activateYourTurnModal()\r\n        break\r\n\r\n      case 'nextStudentNotified': // in this case, the server lets the TA know that the student has been notified\r\n        // msg - the name of the student who was notified\r\n        this.activateTAWaitingModal(msg)\r\n        break\r\n\r\n      default:\r\n        throw new Error(`Message ${msg} is incorrectly formatted`)\r\n    }\r\n  }\r\n\r\n  addMeToQueue() {\r\n    const { me } = this.component.state\r\n\r\n    this.connection.send(\r\n      this.prepareMessage({\r\n        msgType: 'addToQueue',\r\n        msg: JSON.stringify(me),\r\n      })\r\n    )\r\n  }\r\n\r\n  removeMeFromQueue() {\r\n    const { me } = this.component.state\r\n\r\n    this.connection.send(\r\n      this.prepareMessage({\r\n        msgType: 'removeFromQueue',\r\n        msg: JSON.stringify(me),\r\n      })\r\n    )\r\n  }\r\n\r\n  getNextStudent() {\r\n    this.connection.send(\r\n      this.prepareMessage({\r\n        msgType: 'next',\r\n        msg: 'next',\r\n      })\r\n    )\r\n  }\r\n\r\n  prepareMessage(msg) {\r\n    const { courseId } = this.component\r\n    const enrichedPayload = { ...msg, courseId }\r\n    return JSON.stringify(enrichedPayload)\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}