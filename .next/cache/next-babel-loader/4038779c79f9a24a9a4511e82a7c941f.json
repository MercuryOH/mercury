{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst url = 'ws://localhost:8080';\nimport { EventEmitter } from '../components/util/EventEmitter';\nconst role = 'Student';\n/**\r\n * QueueWebSocket controls the web socket business logic for the course queue and\r\n * functions as a controller for the queue state\r\n */\n\nexport default class StudentWebSocketClient {\n  start({\n    me,\n    courseId\n  }) {\n    const {\n      id\n    } = me;\n    this.id = id;\n    this.courseId = courseId;\n    this.connection = new WebSocket(url);\n    this.connection.onopen = this.processConnectionOpen.bind(this);\n    this.connection.onerror = this.processConnectionError.bind(this);\n    this.connection.onmessage = this.processConnectionMessage.bind(this);\n    this.defineEventEmitterCallbacks();\n  }\n\n  defineEventEmitterCallbacks() {\n    EventEmitter.subscribe('greeting', () => {\n      this.connection.send(this.prepareMessage({\n        msgType: 'greeting',\n        msg: this.id\n      }));\n    });\n    EventEmitter.subscribe('signalStudentTimeout', TAName => this.signalStudentTimeout(TAName));\n    EventEmitter.subscribe('signalJoinTA', ({\n      group,\n      TAName,\n      me\n    }) => {\n      this.signalJoinTA(group, TAName, me);\n    });\n    EventEmitter.subscribe('signalDeclineTA', TAName => {\n      this.signalDeclineTA(TAName);\n    });\n    EventEmitter.subscribe('signalCallOver', () => {\n      this.signalCallOver();\n    });\n    EventEmitter.subscribe('signalAddMeToQueue', () => {\n      this.addMeToQueue();\n    });\n    EventEmitter.subscribe('signalRemoveMeFromQueue', () => {\n      this.removeMeFromQueue();\n    });\n    EventEmitter.subscribe('sendOutInvite', ({\n      sender,\n      recepientIds,\n      group\n    }) => {\n      recepientIds.forEach(id => {\n        this.sendOutInvite(sender, id, group);\n      });\n    });\n    EventEmitter.subscribe('requestJoinGroup', data => {\n      this.connection.send(this.prepareMessage({\n        msgType: 'requestJoinGroup',\n        msg: JSON.stringify(data)\n      }));\n    });\n    EventEmitter.subscribe('acceptGroupJoinRequest', msg => {\n      this.connection.send(this.prepareMessage({\n        msgType: 'acceptGroupJoinRequest',\n        msg\n      }));\n    });\n    EventEmitter.subscribe('declineGroupJoinRequest', msg => {\n      this.connection.send(this.prepareMessage({\n        msgType: 'declineGroupJoinRequest',\n        msg\n      }));\n    });\n    EventEmitter.subscribe('classGroupSetChanged', classId => {\n      this.connection.send(this.prepareMessage({\n        msgType: 'classGroupSetChanged',\n        msg: classId\n      }));\n    });\n    EventEmitter.subscribe('userLeaveGroup', group => {\n      this.connection.send(this.prepareMessage({\n        msgType: 'userLeaveGroup',\n        msg: group\n      }));\n    });\n    EventEmitter.subscribe('userJoinGroup', data => {\n      this.connection.send(this.prepareMessage({\n        msgType: 'userJoinGroup',\n        msg: data\n      }));\n    });\n    EventEmitter.subscribe('bidForLeaderPosition', ({\n      userId,\n      groupId\n    }) => {\n      this.connection.send(this.prepareMessage({\n        msgType: 'bidForLeaderPosition',\n        msg: {\n          newLeader: this.id,\n          oldLeader: userId,\n          groupId\n        }\n      }));\n    });\n    EventEmitter.subscribe('screenShareOn', data => {\n      this.connection.send(this.prepareMessage({\n        msgType: 'screenShareOn',\n        msg: data\n      }));\n    });\n  }\n\n  processConnectionOpen() {\n    this.connection.send(this.prepareMessage({\n      msgType: 'greeting',\n      msg: this.id\n    })); // notify the server which courseId this websocket belongs to\n  }\n\n  processConnectionError(error) {\n    console.log(`WebSocket error: ${error}`);\n  }\n\n  activateYourTurnModal(TAName) {\n    EventEmitter.publish('activateYourTurnModal', TAName);\n  }\n\n  updateStudentsInQueue(msg) {\n    EventEmitter.publish('updateStudentsInQueue', msg);\n  }\n\n  updateCurrStudent(msg) {\n    EventEmitter.publish('updateCurrStudent', msg);\n  }\n\n  initializeQueueOnGreeting(msg) {\n    EventEmitter.publish('initializeQueueOnGreeting', msg);\n  }\n\n  activateReceiveInviteModal(msg) {\n    EventEmitter.publish('activateReceiveInviteModal', msg);\n  }\n\n  activateGroupJoinRequestModal(msg) {\n    EventEmitter.publish('activateGroupJoinRequestModal', msg);\n  }\n\n  joinPrivateGroupOnApproval(msg) {\n    EventEmitter.publish('joinPrivateGroupOnApproval', msg);\n  }\n\n  notifyJoinRequestDeclined(msg) {\n    EventEmitter.publish('notifyJoinRequestDeclined', msg);\n  }\n\n  notifyFetchGroups() {\n    EventEmitter.publish('fetchGroups');\n  }\n\n  refreshScreenContainer() {\n    EventEmitter.publish('refreshScreenContainer');\n  }\n\n  changeScreensharer(msg) {\n    EventEmitter.publish('newScreensharer', msg);\n  }\n\n  activateWaitingForNewLeaderModal(data) {\n    console.log(JSON.stringify(data));\n    EventEmitter.publish('activateWaitingForNewLeaderModal', data);\n  }\n\n  removeWaitingForNewLeaderModal(newLeaderId) {\n    EventEmitter.publish('removeWaitingForNewLeaderModal', newLeaderId);\n  }\n\n  processConnectionMessage(e) {\n    const {\n      msgType,\n      msg\n    } = JSON.parse(e.data);\n\n    switch (msgType) {\n      case 'greetingAck':\n        this.initializeQueueOnGreeting(msg);\n        break;\n\n      case 'queue':\n        // in this case, the server will send a message indicating the current students in the queue\n        // msg - the new queue\n        this.updateStudentsInQueue(msg);\n        break;\n\n      case 'yourTurn':\n        // in this case, which is only if you are a student, the server notifies that it is your turn\n        // msg - the TA that notifies you\n        this.activateYourTurnModal(msg);\n        break;\n\n      case 'currStudentUpdate':\n        this.updateCurrStudent(msg);\n        break;\n\n      case 'receiveInvite':\n        // in this case, another student invites you to their group\n        // msg - sender, group\n        this.activateReceiveInviteModal(msg);\n        break;\n\n      case 'groupJoinRequest':\n        this.activateGroupJoinRequestModal(msg); // msg - the name of the student wanting to join\n\n        break;\n\n      case 'groupJoinRequestApproved':\n        this.joinPrivateGroupOnApproval(msg);\n        break;\n\n      case 'groupJoinRequestDeclined':\n        this.notifyJoinRequestDeclined(msg);\n        break;\n\n      case 'fetchGroups':\n        this.notifyFetchGroups();\n        break;\n\n      case 'newLeaderAppointed':\n        this.refreshScreenContainer();\n        break;\n\n      case 'fetchScreensharer':\n        this.changeScreensharer(msg);\n\n      case 'oldLeaderHasLeft':\n        // msg - the old leader Id and the group id\n        this.activateWaitingForNewLeaderModal(msg);\n        break;\n\n      case 'wonLeaderBid':\n        this.removeWaitingForNewLeaderModal(msg);\n        break;\n\n      default:\n        throw new Error(`Message ${msgType} is incorrectly formatted`);\n    }\n  }\n\n  addMeToQueue() {\n    this.connection.send(this.prepareMessage({\n      msgType: 'addToQueue',\n      msg: this.id\n    }));\n    EventEmitter.publish('addMeToQueue');\n  }\n\n  removeMeFromQueue() {\n    this.connection.send(this.prepareMessage({\n      msgType: 'removeFromQueue',\n      msg: this.id\n    }));\n    EventEmitter.publish('removeMeFromQueue');\n  }\n\n  signalStudentTimeout(TAName) {\n    this.connection.send(this.prepareMessage({\n      msgType: 'studentTimeout',\n      msg: TAName\n    }));\n  }\n\n  signalJoinTA(group, TAName, me) {\n    this.connection.send(this.prepareMessage({\n      msgType: 'joinTA',\n      msg: JSON.stringify({\n        group,\n        TAName,\n        me\n      })\n    }));\n    EventEmitter.publish('clearLeftSide');\n  }\n\n  signalDeclineTA(TAName) {\n    this.connection.send(this.prepareMessage({\n      msgType: 'declineTA',\n      msg: TAName\n    }));\n  }\n\n  signalCallOver() {\n    this.connection.send(this.prepareMessage({\n      msgType: 'callOver',\n      msg: 'callOver'\n    }));\n  }\n\n  sendOutInvite(sender, recepientId, group) {\n    this.connection.send(this.prepareMessage({\n      msgType: 'sendOutInvite',\n      msg: JSON.stringify({\n        sender,\n        recepientId,\n        group\n      })\n    }));\n  }\n\n  prepareMessage(msg) {\n    const {\n      courseId\n    } = this;\n\n    const enrichedPayload = _objectSpread(_objectSpread({}, msg), {}, {\n      courseId,\n      role\n    });\n\n    return JSON.stringify(enrichedPayload);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}